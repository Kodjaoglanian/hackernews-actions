name: Hacker News to Discord

on:
  schedule:
    - cron: "0 9 * * *"
  workflow_dispatch:

permissions:
  contents: read

env:
  # Configur√°veis, voc√™ pode substituir no Secrets ou Environment
  NEWS_COUNT: 5           # Quantidade de not√≠cias a enviar
  EMBED_COLOR: 16737843   # Cor da embed em decimal (default laranja #FF6600)
  TIMEZONE: "UTC"         # Fuso hor√°rio para timestamp

jobs:
  send-news:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Python 3.x
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: |
          pip install httpx pytz

      - name: Validate Discord webhook URL
        run: |
          if [ -z "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            echo "::error::‚ùå DISCORD_WEBHOOK_URL is not set. Exiting."
            exit 1
          fi
          echo "‚úÖ Discord webhook URL found."

      - name: Send Hacker News Top Stories to Discord
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          NEWS_COUNT: ${{ env.NEWS_COUNT }}
          EMBED_COLOR: ${{ env.EMBED_COLOR }}
          TIMEZONE: ${{ env.TIMEZONE }}
        run: |
          python << 'EOF'
          import os
          import sys
          import asyncio
          import httpx
          from datetime import datetime
          import pytz

          WEBHOOK_URL = os.getenv("DISCORD_WEBHOOK_URL")
          NEWS_COUNT = int(os.getenv("NEWS_COUNT", 5))
          EMBED_COLOR = int(os.getenv("EMBED_COLOR", 0xFF6600))
          TIMEZONE = os.getenv("TIMEZONE", "UTC")

          def log(msg):
              now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
              print(f"[{now}] {msg}")

          async def fetch_json(client, url, retries=3):
              for attempt in range(1, retries+1):
                  try:
                      resp = await client.get(url, timeout=10)
                      resp.raise_for_status()
                      return resp.json()
                  except Exception as e:
                      log(f"‚ö†Ô∏è Tentativa {attempt} falhou para {url}: {e}")
                      if attempt == retries:
                          return None
                      await asyncio.sleep(1)

          async def get_top_story_ids(client):
              url = "https://hacker-news.firebaseio.com/v0/topstories.json"
              return await fetch_json(client, url) or []

          async def get_story(client, story_id):
              url = f"https://hacker-news.firebaseio.com/v0/item/{story_id}.json"
              return await fetch_json(client, url)

          async def validate_webhook(client, url):
              try:
                  resp = await client.get(url, timeout=10)
                  if resp.status_code == 200:
                      return True
                  else:
                      log(f"‚ùå Webhook URL inv√°lido ou inacess√≠vel: Status {resp.status_code}")
                      return False
              except Exception as e:
                  log(f"‚ùå Erro ao validar webhook URL: {e}")
                  return False

          def build_embed(stories):
              tz = pytz.timezone(TIMEZONE)
              current_time = datetime.now(tz).strftime("%d/%m/%Y %H:%M %Z")

              embed = {
                  "title": "üì∞ Top Not√≠cias do Hacker News",
                  "url": "https://news.ycombinator.com/",
                  "color": EMBED_COLOR,
                  "footer": {
                      "text": f"Atualizado em {current_time}"
                  },
                  "fields": []
              }

              for story in stories:
                  if not story:
                      continue
                  title = story.get("title", "Sem t√≠tulo")
                  url = story.get("url") or f"https://news.ycombinator.com/item?id={story.get('id')}"
                  author = story.get("by", "desconhecido")
                  score = story.get("score", "N/A")
                  comments = story.get("descendants", 0)

                  # Limita t√≠tulo para evitar erro no Discord
                  if len(title) > 256:
                      title = title[:253] + "..."

                  value = (
                      f"[Link da not√≠cia]({url})\n"
                      f"Autor: **{author}**\n"
                      f"Pontos: **{score}** | Coment√°rios: **{comments}**"
                  )

                  embed["fields"].append({
                      "name": title,
                      "value": value,
                      "inline": False
                  })

              return embed

          async def send_discord(webhook_url, embed):
              async with httpx.AsyncClient() as client:
                  valid = await validate_webhook(client, webhook_url)
                  if not valid:
                      raise RuntimeError("Webhook inv√°lido ou inacess√≠vel.")

                  payload = {"embeds": [embed]}
                  resp = await client.post(webhook_url, json=payload, timeout=10)
                  resp.raise_for_status()
                  log("‚úÖ Mensagem enviada com sucesso para o Discord!")

          async def main():
              log("üîç Iniciando coleta das not√≠cias...")
              async with httpx.AsyncClient() as client:
                  top_ids = await get_top_story_ids(client)
                  if not top_ids:
                      log("‚ö†Ô∏è Nenhum ID de not√≠cia retornado.")
                      return

                  tasks = [get_story(client, sid) for sid in top_ids[:NEWS_COUNT]]
                  stories = await asyncio.gather(*tasks)

              embed = build_embed(stories)
              await send_discord(WEBHOOK_URL, embed)

          if __name__ == "__main__":
              try:
                  asyncio.run(main())
              except Exception as e:
                  log(f"‚ùå Erro cr√≠tico: {e}")
                  sys.exit(1)
          EOF
